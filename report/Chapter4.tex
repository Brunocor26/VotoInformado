\chapter{Implementação} \label{chap:implementacao}

Este capítulo aborda os desafios técnicos e as soluções de implementação adotadas durante o desenvolvimento.

\section{Migração para API Customizada} \label{sec:impl_api}
Inicialmente, o projeto utilizava o Firebase Firestore para persistência de dados diretamente na aplicação móvel. Para aumentar a complexidade técnica e centralizar a lógica de negócio, migrou-se para uma arquitetura com uma **API REST intermédia**.

Esta nova arquitetura consiste numa API desenvolvida em \textbf{Node.js}, que atua como \textit{backend} para a aplicação Android. A API utiliza uma base de dados \textbf{MongoDB} para persistência de dados, comunicando através da biblioteca \textbf{Mongoose}. A autenticação é gerida através de \textbf{JWT (JSON Web Tokens)}, garantindo uma sessão segura e independente do estado do servidor.

% [TODO: Inserir Diagrama de Arquitetura]
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.7\textwidth]{images/arquitetura_api.png}
    \fbox{\begin{minipage}{0.7\textwidth}
        \centering
        \vspace{3cm}
        \textbf{[PLACEHOLDER: Arquitetura Cliente-Servidor]} \\
        (Diagrama: Android App <-> Retrofit <-> Node.js API <-> MongoDB)
        \vspace{3cm}
    \end{minipage}}
    \caption{Arquitetura da comunicação com a API customizada.}
    \label{fig:api_arch}
\end{figure}

\begin{lstlisting}[language=Java, caption=Definição da Interface Retrofit]
public interface ApiService {
    @GET("api/candidates")
    Call<List<Candidato>> getCandidates();

    @POST("api/petitions")
    Call<Peticao> createPetition(@Body Peticao peticao);
    
    @Multipart
    @POST("api/petitions/upload")
    Call<Map<String, String>> uploadPetitionImage(@Part MultipartBody.Part image);
}
\end{lstlisting}

\section{Parsing de Notícias (RSS)} \label{sec:impl_rss}
Para obter as notícias, foi implementada a classe \texttt{NoticiasFetcher}. Esta classe realiza uma requisição HTTP ao feed RSS da RTP e faz o parsing do XML resultante utilizando \texttt{DocumentBuilder}.
Um desafio interessante foi a extração de imagens, que não vinham num campo explícito, mas sim embutidas na descrição HTML. Foi utilizada uma expressão regular (Regex) para extrair o atributo \texttt{src} das tags \texttt{<img>}.

% [TODO: Inserir Diagrama de Sequência]
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{images/diagrama_sequencia_noticias.png}
    \fbox{\begin{minipage}{0.8\textwidth}
        \centering
        \vspace{3cm}
        \textbf{[PLACEHOLDER: Diagrama de Sequência]} \\
        (Fluxo: Fragment -> Fetcher -> HTTP Request -> XML Parsing -> Return List)
        \vspace{3cm}
    \end{minipage}}
    \caption{Diagrama de sequência do processo de obtenção de notícias.}
    \label{fig:seq_noticias}
\end{figure}

\section{Gestão de Imagens} \label{sec:impl_imagens}
As imagens das petições e dos candidatos são armazenadas localmente no servidor (\textit{backend}) e servidas como ficheiros estáticos. A base de dados armazena apenas o URL relativo da imagem. Na aplicação Android, a biblioteca \textbf{Picasso} é utilizada para carregar e exibir estas imagens de forma assíncrona, gerindo automaticamente o download, cache e redimensionamento das imagens.

\section{Adapters e RecyclerViews} \label{sec:impl_adapters}
A exibição de listas eficientes foi conseguida através da implementação de \texttt{RecyclerView.Adapter} personalizados. O padrão \textit{ViewHolder} é utilizado para reciclar as vistas, garantindo uma rolagem suave mesmo com listas longas de candidatos ou notícias.

\section{Motor de Quiz e Visualização Gráfica} \label{sec:impl_compass}
A funcionalidade da Bússola Política envolveu o desenvolvimento de um motor de cálculo de pontuação e uma vista personalizada para o gráfico.

\subsection{Modelo de Dados}
A classe \texttt{Question} encapsula o texto da pergunta, o peso e o eixo a que pertence (Económico ou Social). A classe \texttt{CompassCandidate} estende a informação base de um candidato adicionando as coordenadas (x, y) da sua posição política estimada.

\subsection{CompassView}
Para desenhar o gráfico, foi criada a classe \texttt{CompassView} que estende \texttt{View}.
\begin{itemize}
    \item \textbf{onDraw()}: Este método é sobrescrito para desenhar os eixos, as quadrículas de fundo, e os pontos que representam o utilizador e os candidatos.
    \item \textbf{Transformação de Coordenadas}: As coordenadas lógicas (de -10 a +10) são convertidas para coordenadas de ecrã (pixels) tendo em conta a largura e altura da vista, garantindo que o gráfico se adapta a diferentes tamanhos de ecrã.
\end{itemize}

\section{Sistema de Petições} \label{sec:impl_peticoes}
O sistema de petições foi adaptado para consumir a nova API, mantendo a autenticação de utilizadores via Firebase Auth (gerida pelo backend).

\subsection{Estrutura de Dados}
A classe \texttt{Peticao} foi atualizada para mapear os documentos MongoDB.
\begin{lstlisting}[language=Java, caption=Estrutura simplificada da classe Peticao]
public class Peticao {
    @SerializedName("_id")
    private String id;
    private String titulo;
    private String descricao;
    private List<String> assinaturas; // Lista de UIDs
    private String imageUrl; // URL da imagem
    // ... getters e setters
}
\end{lstlisting}

\subsection{Upload de Imagens}
Para permitir o upload de imagens nas petições sem custos adicionais de serviços cloud, implementou-se um sistema de \textbf{armazenamento local} no servidor.
\begin{itemize}
    \item \textbf{Backend}: Utiliza o middleware \texttt{multer} para receber ficheiros \textit{multipart/form-data} e guardá-los numa pasta local \texttt{uploads/}. O servidor serve estes ficheiros estaticamente.
    \item \textbf{Android}: A atividade \texttt{CreatePeticaoActivity} seleciona a imagem da galeria, converte-a num ficheiro temporário e envia-a para o endpoint \texttt{/api/petitions/upload} antes de submeter os dados da petição.
\end{itemize}

\subsection{Eliminação de Petições}
Foi implementada a funcionalidade de eliminação de petições através do método HTTP \texttt{DELETE}. O endpoint \texttt{/api/petitions/:id} permite remover documentos da coleção \texttt{petitions} no Firestore, garantindo a integridade dos dados. A aplicação Android expõe esta funcionalidade através da classe utilitária \texttt{DatabaseHelper}.

\section{Resolução de Problemas e Otimizações} \label{sec:impl_fixes}
Durante a fase final de testes e integração, foram identificados e resolvidos três problemas críticos que afetavam a experiência do utilizador e a estabilidade da aplicação.

\subsection{Ligação de Candidatos em Sondagens}
Foi detetada uma inconsistência na ligação entre os resultados das sondagens e os perfis dos candidatos. O problema devia-se a uma discrepância nos identificadores: a base de dados utilizava IDs do MongoDB (\texttt{\_id}), enquanto alguns resultados de sondagens referenciavam candidatos por um ID textual (e.g., "andre\_pestana").

\textbf{Solução}: Implementou-se uma lógica de correspondência robusta nos adaptadores (\texttt{ResultadoSondagemAdapter}, \texttt{SondagemAdapter}) e no \texttt{HomeFragment}. O algoritmo tenta agora corresponder o candidato sequencialmente por:
\begin{enumerate}
    \item ID do MongoDB (\texttt{\_id}).
    \item ID textual personalizado (\texttt{id}).
    \item Nome do candidato (como recurso final, insensível a maiúsculas/minúsculas).
\end{enumerate}

\subsection{Conectividade com API (Render Cold Start)}
A API, alojada no plano gratuito do serviço Render, entra em modo de suspensão após períodos de inatividade. O tempo de arranque inicial ("cold start") excedia frequentemente o timeout padrão de 1.5 segundos definido no cliente Android, levando a aplicação a falhar silenciosamente para o URL local (\texttt{localhost}).

\textbf{Solução}: O timeout de conexão e leitura no \texttt{ApiClient} foi aumentado para \textbf{15 segundos}. Isto garante que a aplicação aguarda o tempo suficiente para que o servidor acorde, assegurando uma conexão bem-sucedida mesmo após inatividade.

\subsection{Carregamento de Imagens de Perfil}
Identificou-se que as imagens de perfil dos utilizadores não eram carregadas corretamente em dispositivos físicos. A causa raiz era dupla: o backend guardava URLs absolutos (e.g., \texttt{http://localhost:3000/...}) durante o registo, que são inacessíveis externamente, e os comentários não persistiam a foto do autor.

\textbf{Solução}:
\begin{itemize}
    \item \textbf{Backend}: O controlador de autenticação foi atualizado para guardar apenas o \textbf{caminho relativo} da imagem (e.g., \texttt{/uploads/profiles/...}). Adicionalmente, a criação de comentários foi corrigida para persistir o URL da foto do autor.
    \item \textbf{Frontend}: Implementou-se uma lógica de "sanitização" no cliente (\texttt{HomeFragment}, \texttt{ComentarioAdapter}). A aplicação deteta agora URLs legados contendo "localhost" ou "127.0.0.1", converte-os em caminhos relativos e prepõe dinamicamente o URL base correto da API (\texttt{ApiClient.getBaseUrl()}).
\end{itemize}
